## Model Classes
A model class represents a single table within your database.  Fields within your model class represent columns in the table.  The object types of your fields are reflectively mapped to SQL types by iciql at runtime.

Models can be manually written using one of two approaches: *annotation configuration* or *interface configuration*.  Both approaches can be used within a project and both can be used within a single model class, although that is discouraged.

Alternatively, model classes can be automatically generated by iciql using the model generation tool.  Please see the [tools](tools.html) page for details.

### Configuration Requirements and Limitations

1. Your model class **must** provide a public default constructor.
2. Only the specified types are supported.  Other types such as arrays and custom types are not supported.
3. Triggers, views, and other advanced database features are not supported.

### Fully Supported Data Types
The following data types can be used for all iciql expressions.
<table>
<tr><th colspan="2">All Databases</th></tr>
<tr><td>java.lang.String</td>
<td>VARCHAR *(length > 0)* or TEXT *(length == 0)*</td></tr>
 	
<tr><td>java.lang.Boolean</td>
<td>BIT</td></tr>
	
<tr><td>java.lang.Byte</td>
<td>TINYINT</td></tr>
	
<tr><td>java.lang.Short</td>
<td>SMALLINT</td></tr>
	
<tr><td>java.lang.Integer</td>
<td>INT</td></tr>
	
<tr><td>java.lang.Long</td>
<td>BIGINT</td></tr>
	
<tr><td>java.lang.Float</td>
<td>REAL</td></tr>
	
<tr><td>java.lang.Double</td>
<td>DOUBLE</td></tr>
	
<tr><td>java.math.BigDecimal</td>
<td>DECIMAL</td></tr>
	
<tr><td>java.sql.Date</td>
<td>DATE</td></tr>
	
<tr><td>java.sql.Time</td>
<td>TIME</td></tr>
	
<tr><td>java.sql.Timestamp</td>
<td>TIMESTAMP</td></tr>

<tr><td>java.util.Date</td>
<td>TIMESTAMP</td></tr>

<tr><td>java.lang.Enum.name()<br/>*default type*</td>
<td>VARCHAR *(length > 0)* or TEXT *(length == 0)*<br/>*EnumType.NAME*</td></tr>

<tr><td>java.lang.Enum.ordinal()</td>
<td>INT<br/>*EnumType.ORDINAL*</td></tr>

<tr><td>java.lang.Enum implements<br/>*com.iciql.Iciql.EnumId.enumId()*</td>
<td>INT<br/>*EnumType.ENUMID*</td></tr>

<tr><th colspan="2">H2 Databases</th></tr>
<tr><td>java.util.UUID</td>
<td>UUID</td><tr/>

</table>

**NOTE:**<br/>
The reverse lookup used for model generation, SQL type -> Java type, contains more mappings.<br/>
Please consult the `com.iciql.ModelUtils` class for details. 

### Partially Supported Data Types
The following data types can be mapped to columns for all general statements <u>BUT</u> these field types may **not** be used to specify **compile-time** *clauses or constraints*.

<table>
<tr><td>byte []</td>
<td>BLOB</td></tr>

<tr><td>boolean</td>
<td>BIT</td></tr>
	
<tr><td>byte</td>
<td>TINYINT</td></tr>
	
<tr><td>short</td>
<td>SMALLINT</td></tr>
	
<tr><td>int</td>
<td>INT</td></tr>
	
<tr><td>long</td>
<td>BIGINT</td></tr>
	
<tr><td>float</td>
<td>REAL</td></tr>
	
<tr><td>double</td>
<td>DOUBLE</td></tr>

</table>

#### Partially Supported Data Types Example
%BEGINCODE%
class Primitives {
    @IQColumn(primaryKey = true)
    int id;
        
    @IQColumn
    String name;
        
    public Primitives() {
    }
    
    public Primitives(int id, String name) {
        this.id = id;
        this.name = name;
    }    
}
    
Primitives p = new Primitives();

// the following expressions compile, but will throw iciql runtime exceptions
db.from(p).where(p.id).is(100).selectFirst();
db.from(p).where(p.id).atLeast(10).select();

// the following expressions will work as expected
db.from(p).select();
db.from(p).where("id = ?", 100).selectFirst();
db.from(p).where("id >= ?", 10).select();
db.insert(new Primitives(150, "test"));
db.update(new Primitives(150, "modified"));
db.delete(new Primitives(150, "test"));
%ENDCODE%


## Annotation Configuration
The recommended approach to setup a model class is to annotate the class and field declarations.

### advantages

- annotated fields may have any scope
- annotated fields may specify default values
- annotated models support annotated field inheritance making it possible to design a single base class that defines the fields and then create table subclasses that specify the table mappings.
- model runtime dependency is limited to the small, portable `com.iciql.Iciql` class file which contains the annotation definitions

### disadvantages

- more verbose model classes
- indexes are defined using "fragile" string column names
- compound primary keys are defined using "fragile" string column names

### default values

You may specify default values for an @IQColumn by either:

1. specifying the default value string within your annotation<br/>
%BEGINCODE%
// notice the single ticks!
@IQColumn(defaultValue="'2000-01-01 00:00:00'")
Date myDate;
%ENDCODE%
2. setting a default object on the field<br/>
%BEGINCODE%
@IQColumn
Date myDate = new Date(100, 0, 1);
%ENDCODE%

If you want to specify a database-specific variable or function as your default value (e.g. CURRENT_TIMESTAMP) you must do that within the annotation.  Also note that the IQColumn.defaultValue must be a well-formatted SQL DEFAULT expression whereas object defaults will be automatically converted to an SQL DEFAULT expression.
 
### Example Annotated Model
%BEGINCODE%
import com.iciql.Iciql.EnumType;
import com.iciql.Iciql.IQColumn;
import com.iciql.Iciql.IQEnum;
import com.iciql.Iciql.IQIndex;
import com.iciql.Iciql.IQTable;

@IQTable
@IQIndexes({
  @IQIndex({"productName", "category"}),
  @IQIndex(name="nameindex", value="productName")
})
public class Product {

	@IQEnum(EnumType.ORDINAL)
	public enum Availability {
		ACTIVE, DISCONTINUED;
	}

	@IQColumn(primaryKey = true)
	public Integer productId;
      
	@IQColumn(length = 200, trim = true)
	public String productName;
      
	@IQColumn(length = 50, trim = true)
	public String category;
      
	@IQColumn
	public Double unitPrice;
      
	@IQColumn(name = "units")
	public Integer unitsInStock;
      
	@IQColumn
	private Integer reorderQuantity;
	
	@IQColumn
	private Availability availability;
      
	public Product() {
		// default constructor
	}
}
%ENDCODE%

## Interface Configuration (deprecated)
Alternatively, you may map your model classes using the original JaQu interface approach by implementing the `com.iciql.Iciql` interface.

This is a less verbose configuration style, but it comes at the expense of introducing a compile-time dependency on the logic of the iciql library.  This might be a deterrent, for example, if you were serializing your model classes to another process that may not have the iciql library.

The `com.iciql.Iciql` interface specifies a single method, *defineIQ()*.  In your implementation of *defineIQ()* you would use static method calls to set:

- the table name (if it's not the class name)
- the column name (if it's not the field name)
- the max length of a string field
- the primaryKey (single field or compound)
- any indexes (single field or compound)

### advantages

- less verbose model class
- compile-time index definitions
- compile-time compound primary key definitions

### disadvantages

- <u>only **public** fields of the model class are reflectively mapped as columns</u>. all other scoped fields and inherited fields are ignored.
- model runtime dependency on entire iciql library
- *defineIQ()* is called from a static synchronized block which may be a bottleneck for highly concurrent systems

### Example Interface Model
%BEGINCODE%
import com.iciql.Iciql;

public class Product implements Iciql {
	public Integer productId;
	public String productName;
	public String category;
	public Double unitPrice;
	public Integer unitsInStock;
	
	// this field is ignored because it is not public
	Integer reorderQuantity;
      
	public Product() {
	}
      
	@Override
	public void defineIQ() {
		com.iciql.Define.primaryKey(productId);
		com.iciql.Define.columnName(unitsInStock, "units");
		com.iciql.Define.length(productName, 200);
		com.iciql.Define.length(category, 50);
		com.iciql.Define.index(productName, category);
	}
}
%ENDCODE%